package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path"
	"strings"
)

// Item is a definition of an item.
type Item struct {
	ID        int    `json:"id"`
	Name      string `json:"name"`
	Duplicate bool   `json:"duplicate"`
}

func main() {
	var itemFilePath, scriptOutDir string
	var maxItemID int
	flag.StringVar(&itemFilePath, "item-file", "", "Path to the item JSON file")
	flag.StringVar(&scriptOutDir, "script-output-dir", "", "Path to the directory where script data will be written")
	flag.IntVar(&maxItemID, "max-item-id", 32000, "Maximum item ID to parse, inclusive")
	flag.Parse()

	data, err := os.ReadFile(itemFilePath)
	if err != nil {
		fmt.Printf("unable to open file %s: %s\n", itemFilePath, err)
		os.Exit(1)
	}

	var db map[string]Item
	err = json.Unmarshal(data, &db)
	if err != nil {
		fmt.Printf("failed to parse item file: %s", err)
		os.Exit(1)
	}

	// track which item names have already been used, and disambiguate by appending incrementing numbers
	usedNames := map[string]int{}

	scriptConstants := "-- automatically generated by openmcs/itemgen"
	for i := 0; i <= maxItemID; i++ {
		// skip duplicate items
		item, ok := db[fmt.Sprintf("%d", i)]
		if !ok || item.Duplicate {
			continue
		}

		// replace various special characters with placeholders to form valid lua syntax
		normalizedName := strings.Replace(item.Name, " ", "_", -1)
		normalizedName = strings.Replace(normalizedName, "-", "_", -1)
		normalizedName = strings.Replace(normalizedName, "'", "", -1)
		normalizedName = strings.Replace(normalizedName, "(", "", -1)
		normalizedName = strings.Replace(normalizedName, ")", "", -1)
		normalizedName = strings.Replace(normalizedName, "/", "", -1)
		normalizedName = strings.Replace(normalizedName, "&", "", -1)
		normalizedName = strings.Replace(normalizedName, ".", "", -1)
		normalizedName = strings.Replace(normalizedName, "+", "", -1)
		normalizedName = strings.Replace(normalizedName, "?", "Q", -1)
		normalizedName = strings.ToUpper(normalizedName)

		// disambiguate duplicate names
		if count, ok := usedNames[normalizedName]; ok {
			usedNames[normalizedName] = count + 1
			normalizedName = fmt.Sprintf("%s%d", normalizedName, count+1)
		} else {
			usedNames[normalizedName] = 1
		}

		scriptConstants = fmt.Sprintf("%s\nITEM_%s = %d", scriptConstants, normalizedName, item.ID)
	}

	// write the constants file out
	scriptConstantsFile := path.Join(scriptOutDir, "items.lua")
	err = os.WriteFile(scriptConstantsFile, []byte(scriptConstants), 0755)
	if err != nil {
		fmt.Printf("failed to write script constants file to %s: %s", scriptConstantsFile, err)
		os.Exit(1)
	}

	fmt.Printf("wrote script constants to: %s\n", scriptConstantsFile)
}
